---
title: "Reproducible Analysis of Zurich Leerkündigungen"
subtitle: "Open Government Data Analysis"
author: "Automated Analysis"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: cosmo
    highlight: tango
    code_folding: hide
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 6,
  dpi = 300
)

# Load required libraries
library(tidyverse)
library(readr)
library(dplyr)
library(ggplot2)
library(knitr)
library(scales)
library(forcats)

# Source all analysis scripts
source("../scripts/utils.R")
source("../scripts/01_load.R")
source("../scripts/02_explore.R")
source("../scripts/03_analyze.R")
source("../scripts/04_visualize.R")
```

# Executive Summary
Unterscheiden sich Zielorte nach Leerkündigungen systematisch nach Altersgruppen.
Zwischen 2010 und 2023 wurden 8’559 Personen aufgrund von Leerkündigungen erfasst. Rund X % zogen innerhalb der Stadt um, wobei dieser Anteil stark altersabhängig ist. Jüngere und sehr alte Altersgruppen zeigen signifikant unterschiedliche Zielmuster (χ²-Test, p < 0.001), allerdings mit kleiner Effektstärke (Cramér’s V ≈ 0.07–0.09). Über die Zeit bleiben die Zielort-Strukturen bemerkenswert stabil, trotz jährlicher Schwankungen in der Anzahl Betroffener. !!!Todo mach es besser!!!

---

# 1. Data Loading and Validation

## 1.1 Dataset Source

Daten stammen vom OGD daten satz *** Hier Was Schreiben ***

**Official URL**: `https://data.stadt-zuerich.ch/dataset/bau_umbau_leerkuendigung_wohnortsgebiete_ag_personen_od5052/download/BAU505OD5052.csv`

```{r load-data}
# Load dataset from official URL
df_raw <- load_and_validate(DATASET_URL)
```

## 1.2 Column names

The dataset uses German column names. Map them to English names:

```{r field-mapping}
# Display new names
mapping_table <- data.frame(
  `New name` = names(FIELD_MAPPINGS),
  `Original name` = unlist(FIELD_MAPPINGS)
)

kable(mapping_table, caption = "Name Mappings")

# Apply renaming
df <- map_fields(df_raw)
```

---

# 2. Methodology

## 2.1 Aggregation Measure

**Definition**: All totals, shares, and comparisons use the **affected persons count** (`AnzPersonWir` in the dataset). This is the number of individuals who received a Leerkündigung.

## 2.2 Within/Outside City Categories

We define a binary grouping of residence outcomes for a first analysis:

**Within Zurich City**:

- `r WITHIN_CITY_CATEGORIES[1]` (Same city quarter)
- `r WITHIN_CITY_CATEGORIES[2]` (Different city quarter)

**Outside Zurich City**: All other residence categories (excluding "Unknown" if analyzed separately)

```{r within-outside-mapping}
# Display residence categories and their classification
residence_classification <- df %>%
  select(new_residence, within_city) %>%
  distinct() %>%
  arrange(desc(within_city), new_residence) %>%
  mutate(Classification = ifelse(within_city, "Within City", "Outside City"))

kable(residence_classification %>% select(new_residence, Classification), 
      caption = "Residence Category Classification")
```

## 2.3 Unknown Category Handling

If an "Unknown" category exists in the data:

- It is **reported explicitly** (not silently removed)
- Its distribution across age groups is analyzed separately (Q5)
- It is **excluded** from the Within/Outside city binary analysis to avoid bias

---

# 3. Exploration
## 3.1 Summary Statistics
Die Tabelle fasst die wichtigsten Eckwerte des Datensatzes zusammen: den beobachteten Zeitraum, die Gesamtzahl der betroffenen Personen sowie die Anzahl  Altersgruppen und Wohnort-Kategorien.

```{r summary-statistics-table}
exploration_results <- explore_dataset(df)
##  Summary Stats
summary_stats <- tibble::tibble(
  Metrik = c(
    "Zeitraum (von)",
    "Zeitraum (bis)",
    "Zeitraum (Jahre)",
    "Total Betroffene Personen",
    "Anzahl Altersgruppen",
    "Anzahl Wohnort-Kategorien"
  ),
  Wert = c(
    exploration_results$time_range$earliest,
    exploration_results$time_range$latest,
    exploration_results$time_range$span,
    format(exploration_results$total_count, big.mark = ","),
    length(exploration_results$age_groups),
    length(exploration_results$residence_categories)
  )
)

knitr::kable(
  summary_stats,
  caption = "Zusammenfassung: wichtigste Kennzahlen"
)

```


## ## 3.2 Kategorie "Unbekannt"

```{r unknown-check}

unknown_tbl <- tibble::tibble(
  Merkmal = c("Kategorie 'Unbekannt' vorhanden", "Anzahl", "Anteil"),
  Wert = c(
    ifelse(exploration_results$unknown_info$exists, "Ja", "Nein"),
    format(exploration_results$unknown_info$count, big.mark = ","),
    paste0(round(exploration_results$unknown_info$share * 100, 1), "%")
  )
)

knitr::kable(unknown_tbl, caption = "Übersicht zur Kategorie 'Unbekannt'")

```

---

# 4. Analyse

## 4.1 Veränderung über die Zeit

```{r zeit-analysis}
time_results <- analyze_time_change(df)
```

Die folgende Auswertung zeigt, wie sich die Gesamtzahl betroffener Personen im Zeitverlauf entwickelt. Der Höchstwert liegt im Jahr/den Jahren `r paste(time_results$peak_years, collapse = ", ")` mit `r format(time_results$peak_count, big.mark = ",")` betroffen. Es gibt eine Zunahme bis ins Jahr 2017, mit eineme Ausreiiser in 2015. Nachher folgt eine abnahme und stabilisierung der Leerkuendigungen.

```{r q1-visualization, fig.cap="Betroffene Personen über die Zeit"}
plot_persons_per_time(time_results$temporal_summary)
```

---

## 4.2 Verteilung der Zielorte

Die folgende Darstellung zeigt die Verteilung der Zielorte nach einer Leerkündigung über die Jahre. Das Jahr 2010 scheint ein ausreisser zu sein, wahrend es sonst, ueber alle gruppen gesehen, stabil ist. # Todo testen, deviant year teil wegnehmen in residence result

```{r zielorte-analysis}
residence_results <- analyze_composition_shift(df)

```

```{r q2-visualization, fig.cap="Residence composition over time"}
plot_composition_shift(residence_results$composition_summary)
```


---

## 4.3 Aenderung nach Altersgruppe

```{r q3-analysis}
# Für diese Auswertung wird die Kategorie "Unbekannt" ausgeschlossen
df_known <- filter_unknown(df)
q3_results <- analyze_age_gradient(df_known)
```

Die Auswertung zeigt Unterschiede zwischen den Altersgruppen innerhalb der Stadt Zürich zu bleiben. Den höchsten Anteil «innerhalb der Stadt» hat `r q3_results$max_age_group` mit `r round(q3_results$max_share * 100, 1)`%, den niedrigsten `r q3_results$min_age_group` mit `r round(q3_results$min_share * 100, 1)` %. Das entspricht einer Differenz von `r round(q3_results$contrast * 100, 1)` Prozentpunkten.

```{r q3-visualization, fig.cap="Within-city share by age group"}
plot_age_gradient(q3_results$age_summary)
```

```{r q3-table}
q3_table <- q3_results$age_summary %>%
  mutate(
    `Anteil innerhalb der Stadt` = paste0(round(within_city_share * 100, 1), "%"),
    `Total` = format(total_count, big.mark = ",")
  ) %>%
  select(`Altersgruppe` = age_group, `Anteil innerhalb der Stadt`, `Total`)

kable(q3_table, caption = "Anteil innerhalb der Stadt nach Altersgruppe", align = c("l", "r", "r"))
```


---

## 4.4 Verbleib im gleichen Stadtquartier

```{r q4-analysis}
# Todo zeige einfach die same share im selben quartier, allenfalls mache ienen test
q4_results <- analyze_same_quarter(df)
```

Anteil der betroffenen Personen, die nach einer Leerkündigung im gleichen Stadtquartier bleiben (falls diese Kategorie im Datensatz vorhanden ist). Den höchsten Anteil weist `r q4_results$max_age_group` mit `r round(q4_results$max_share * 100, 1)`% auf, den niedrigsten `r q4_results$min_age_group` mit `r round(q4_results$min_share * 100, 1)`%. Das entspricht einer Differenz von `r round(q4_results$contrast * 100, 1)` Prozentpunkten.

```{r q4-visualization, eval=q4_results$applicable}
plot_same_quarter(q4_results$same_quarter_summary)
```

```{r q4-table, eval=q4_results$applicable}
q4_table <- q4_results$same_quarter_summary %>%
  mutate(
    `Anteil gleiches Stadtquartier` = paste0(round(same_quarter_share * 100, 1), "%"),
    `Anzahl (gleiches Stadtquartier)` = format(same_quarter_count, big.mark = ","),
    `Total` = format(total, big.mark = ",")
  ) %>%
  select(`Altersgruppe` = age_group, `Anteil gleiches Stadtquartier`, `Anzahl (gleiches Stadtquartier)`, `Total`)

kable(q4_table, caption = "Anteil im gleichen Stadtquartier nach Altersgruppe", align = c("l", "r", "r", "r"))
```

---

## 4.5 Kategorie „Unbekannt“ nach Altersgruppe

```{r q5-analysis}
q5_results <- analyze_unknown_concentration(df)
```

Den höchsten Anteil "Unbekant" weist `r q5_results$max_age_group` mit `r round(q5_results$max_share * 100, 1)`% auf, den niedrigsten r `q5_results$min_age_group` mit `r round(q5_results$min_share * 100, 1)`%. Das entspricht einer Differenz von `r round(q5_results$contrast * 100, 1)` Prozentpunkten.
Mögliche nicht-kausale Erklärungen (ohne Anspruch auf Vollständigkeit) sind unterschiedliche Erfassungs- oder Meldepraktiken, variierende Mobilität zwischen Altersgruppen sowie zeitliche Änderungen in der Datenqualität.


```{r q5-visualization, eval=q5_results$applicable}
plot_unknown_concentration(q5_results$unknown_summary)

```

```{r q5-table}
q5_table <- q5_results$unknown_summary %>%
  mutate(
    `Anteil „Unbekannt“` = paste0(round(unknown_share * 100, 1), "%"),
    `Anzahl „Unbekannt“` = format(unknown_count, big.mark = ","),
    `Total` = format(total, big.mark = ",")
  ) %>%
  select(`Altersgruppe` = age_group, `Anteil „Unbekannt“`, `Anzahl „Unbekannt“`, `Total`)

kable(q5_table, caption = "Kategorie „Unbekannt“ nach Altersgruppe", align = c("l", "r", "r", "r"))
```

---

# 5. Altersabhängige Unterschiede im Verbleib innerhalb und ausserhalb der Stadt

## 5.1 Chi-Quadrat-Test

Zur Einordnung, ob sich die Verteilung **„innerhalb der Stadt“ vs. „ausserhalb der Stadt“** zwischen Altersgruppen unterscheidet, wird mit  einen Chi-Quadrat-Test auf Unabhängigkeit (auf aggregierten Zählwerten; ohne Kategorie „Unbekannt“; siehe oben) getestet.

```{r statistical-test}
# Kontingenztafel (ohne "Unbekannt")
contingency_table <- df_known %>%
  mutate(outcome = ifelse(within_city, "Innerhalb der Stadt", "Ausserhalb der Stadt")) %>%
  group_by(age_group, outcome) %>%
  summarise(count = sum(count, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = outcome, values_from = count, values_fill = 0) %>%
  column_to_rownames("age_group") %>%
  as.matrix()

# Chi-Quadrat-Test
chi_result <- chisq.test(contingency_table)

# Effektgrösse: Cramér's V
n <- sum(contingency_table)
v <- cramers_v(chi_result, contingency_table)

# Resultate als Tabelle
chi_table <- tibble::tibble(
  Kennwert = c("Teststatistik (χ²)", "Freiheitsgrade", "p-Wert", "Cramer's V"),
  Wert = c(
    round(as.numeric(chi_result$statistic), 2),
    as.numeric(chi_result$parameter),
    format.pval(chi_result$p.value, digits = 3),
    round(v, 3)
  )
)

knitr::kable(chi_table, caption = "Chi-Quadrat-Test: Altersgruppe × (innerhalb/ausserhalb der Stadt)")
```

```{r contingency-table}
kable(contingency_table, caption = "Kontingenztafel: Altersgruppe × Ziel (innerhalb/ausserhalb der Stadt)")
```

Der Chi-Quadrat-Test deutet auf einen Zusammenhang zwischen Altersgruppe und Ziel (innerhalb/ausserhalb der Stadt) hin (p = `r format.pval(chi_result$p.value, digits = 3)`). Die Effektgrösse **Cramér’s V** beträgt `r round(v, 3)` und entspricht einem kleinen Effekt.

---

# 6. Verteilungen Zwischen Zielorten und Altersgruppen
Der globale Chi-Quadrat-Test basiert auf einer binären Klassifikation der Zielorte (innerhalb vs. ausserhalb der Stadt), um einen robusten Gesamteindruck zu erhalten. In einem zweiten Schritt wird diese Kategorie „ausserhalb der Stadt“ weiter aufgeschlüsselt, um zu untersuchen, welche spezifischen Zielorte zu den beobachteten Unterschieden beitragen.

```{r analyze-age-residence}
# Prepare data for detailed age x residence analysis
age_residence_results <- analyze_age_residence_distributions(df)
Rlong <- age_residence_results$Rlong
log2RR_long <- age_residence_results$log2RR_long
O_matrix <- age_residence_results$O_matrix # Use the raw matrix for 6.5
```

## 6.3 Standardisierte Residuen (Alter × Zielort): Wo liegt der Zusammenhang genau?
Die Heatmap zeigt pro Kombination aus Altersgruppe und Zielort standardisierte Residuen. Werte > 0 (rot) bedeuten, dass diese Kombination häufiger beobachtet wird als unter der Annahme von Unabhängigkeit zu erwarten wäre; Werte < 0 (blau) entsprechend seltener. Auffällig ist, dass 20–39-Jährige beim Zielort „gleiches Stadtquartier“ deutlich unterrepräsentiert sind, während sie bei „übrige Schweiz“ und „Ausland“ überrepräsentiert sind. Bei 60–79-Jährigen zeigt sich dagegen eine Überrepräsentation im gleichen Stadtquartier. Zudem ist die Kategorie „Unbekannt“ bei den 80–99-Jährigen stark überrepräsentiert; dies ist primär als Hinweis auf mögliche Unterschiede in der Abdeckung bzw. Zuordenbarkeit der Zielort-Information zu lesen.

```{r fig-residua-heatmap, fig.cap="Standardisierte Residuen: Alter × Zielort", message=FALSE, warning=FALSE}
# Rlong data is prepared in the previous chunk.
# Note: the data preparation logic in the new analyze_function handles the ordering.
plot_standardized_residua(Rlong)
```


# 6.4 log2(Relativrisiko) (Alter × Zielort): Über-/Unterrepräsentation verständlich quantifizieren

Diese Heatmap ergänzt die Residuen, indem sie die Abweichungen als log2(Relativrisiko) darstellt. Ein Wert von 0 bedeutet „entspricht dem Gesamtdurchschnitt“. Positive Werte zeigen, dass ein Zielort innerhalb einer Altersgruppe überdurchschnittlich häufig vorkommt, negative Werte entsprechend unterdurchschnittlich häufig. Die Farbskala ist gekappt, damit einzelne extreme Zellen die Lesbarkeit nicht dominieren.

In den Daten fällt insbesondere auf, dass 20–39-Jährige im Vergleich zum Gesamtdurchschnitt häufiger in den Kategorien „übrige Schweiz“ und „Ausland“ erscheinen und seltener im „gleichen Stadtquartier“. Zudem sticht „Unbekannt“ bei den 80–99-Jährigen klar hervor; das ist vor allem als Hinweis auf Unterschiede in der Abdeckung/Zuordenbarkeit der Zielort-Information zu verstehen

```{r fig-log2rr-heatmap, message=FALSE, warning=FALSE, fig.cap="log2(Relativrisiko): Abweichung vom Gesamtdurchschnitt nach Altersgruppe und Zielort"}
# log2RR_long data is prepared in the previous chunk.
plot_log2_relative_risk(log2RR_long, cap = 2.5)
```


# 7. Limitationen

- Ohne Bezug zur Altersstruktur der Gesamtbevölkerung können wir nicht beurteilen, ob bestimmte Altersgruppen über- oder unterproportional betroffen sind.
- Der Datensatz erfasst nur Personen mit gemeldeter Leerkündigung und nicht nicht alle Umzüge.


# Appendix:

## Appendix A1: Supplementary Figures

```{r supp-figure-a1}

# Aggregieren nach alter und wohnort
p13_data <- df %>%
  # new_residence_sort zur Gruppierung hinzu, um die Sortierreihenfolge zu erhalten
  group_by(age_group, AlterV20Sort, new_residence, new_residence_sort) %>%
  summarise(x = sum(count, na.rm = TRUE), .groups = "drop") %>%
  group_by(age_group, AlterV20Sort) %>%
  mutate(share = x / sum(x)) %>%
  ungroup() %>%
  # new_residence sortieren und als Factor festlegen
  arrange(new_residence_sort) %>%
  mutate(new_residence = fct_inorder(new_residence)) %>%
  # 2. Altersgruppen sortieren 
  arrange(AlterV20Sort) %>%
  mutate(age_group = fct_inorder(age_group))

# stacked plot 
p13 <- ggplot(p13_data, aes(x = age_group, y = share, fill = new_residence)) +
  geom_col(width = 0.85) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Zielorte nach Leerkündigung: Zusammensetzung pro Altersgruppe",
    x = "Altersgruppe",
    y = "Anteil (100%)",
    fill = "Neuer Wohnort"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

p13
```

## 6.2 Total variations-Distanzmatrix: Wie ähnlich sind die Jahre bezüglich Zielort-Verteilung?

Um zu prüfen, ob sich die Zielorte nach Leerkündigung über die Zeit nur in der Menge, aber auch in der **Struktur** (Komposition) verändern, berechne ich für jedes Jahr die Verteilung der Kategorien `new_residence` als **Anteile**.

Für jedes Jahr \(t\) ergibt sich ein Vektor \(p^{(t)} = (p_1^{(t)}, \dots, p_K^{(t)})\), wobei \(p_i^{(t)}\) der Anteil der Betroffenen ist, die im Zielort \(i\) landen (Summe über alle Zielorte = 1).

Als Distanzmass verwende ich die **Total-Variation-Distanz (TV)** zwischen zwei Verteilungen \(p\) und \(q\):

\[
TV(p, q) \;=\; \frac{1}{2}\sum_{i=1}^{K} |p_i - q_i|
\]

**Interpretation:**
- \(TV = 0\): die beiden Jahre haben **identische** Zielort-Verteilungen.
- Je grösser \(TV\), desto **stärker** unterscheiden sich die Kompositionen.
- \(TV\) liegt immer zwischen 0 und 1. Als Faustregel: ein \(TV\) von 0.10 bedeutet, dass man insgesamt etwa 10 Prozentpunkte „Masse“ zwischen Kategorien verschieben müsste, um die eine Verteilung in die andere zu überführen.

Die resultierende paarweise Distanzmatrix über alle Jahre visualisiere ich als Heatmap: dunklere Felder markieren Jahre, deren Zielort-Verteilungen sich deutlich unterscheiden; helle Felder markieren ähnliche Jahre.

```{r vergleich distance matrix jahre}

shares <- df %>%
  group_by(year, new_residence) %>%
  summarise(x = sum(count, na.rm = TRUE), .groups = "drop") %>%
  group_by(year) %>%
  mutate(p = x / sum(x)) %>%
  ungroup() %>%
  select(year, new_residence, p) %>%
  pivot_wider(names_from = new_residence, values_from = p, values_fill = 0) %>%
  arrange(year)

years <- shares$year
M <- as.matrix(dplyr::select(shares, -year))

# Total Variation (TV) = 0.5 * L1 (Manhattan) distance between share vectors
D <- as.matrix(dist(M, method = "manhattan")) * 0.5
dimnames(D) <- list(years, years)

p4b_data <- as.data.frame(as.table(D)) %>%
  rename(y1 = Var1, y2 = Var2, tv = Freq)

p4b <- ggplot(p4b_data, aes(y2, y1, fill = tv)) +
  geom_tile() +
  labs(title = "TV-Distanzmatrix der Jahre (0 = identisch)", x = "Jahr", y = "Jahr")

p4b

```


## Appendix A2: Methodische Hinweise
Standardisierte Residuen (Alter × Zielort): Wo liegt der Zusammenhang genau?

Ein globaler Zusammenhang zwischen Altersgruppen und Zielorten ist leicht festzustellen, aber für die Interpretation ist entscheidend: **Welche Kombinationen treiben den Effekt?**  
Dafür berechne ich für die Kontingenztafel `age_group × new_residence` sogenannte **standardisierte Residuen** (Pearson-Residuen).

Zuerst aggregiere ich die beobachteten Häufigkeiten \(O_{a,r}\) (Summe von `count`) pro Altersgruppe \(a\) und Zielort \(r\).  
Unter der Nullhypothese **Unabhängigkeit** (Alter und Zielort sind unabhängig) wäre die erwartete Häufigkeit:

\[
E_{a,r} \;=\; \frac{(\text{Zeilensumme}_a)\,(\text{Spaltensumme}_r)}{\text{Gesamtsumme}}
\]

Das standardisierte Residuum ist dann:

\[
R_{a,r} \;=\; \frac{O_{a,r} - E_{a,r}}{\sqrt{E_{a,r}}}
\]

**Interpretation:**
- \(R_{a,r} > 0\): diese Kombination tritt **häufiger** auf als bei Unabhängigkeit erwartet (Überrepräsentation).
- \(R_{a,r} < 0\): diese Kombination tritt **seltener** auf als erwartet (Unterrepräsentation).
- Je grösser \(|R_{a,r}|\), desto stärker ist die lokale Abweichung (praktisch “Treiber-Zellen” des Zusammenhangs).

Ich visualisiere \(R_{a,r}\) als Heatmap, um die wichtigsten Abweichungen auf einen Blick zu erkennen.


# Appendix B: Session Information

```{r session-info}
sessionInfo()
```

---

**Analysis completed**: `r Sys.time()`  
**Execution time**: `r round(as.numeric(Sys.time() - knitr::opts_chunk$get("start_time"), units = "secs"), 1)` seconds
